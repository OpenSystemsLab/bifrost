---
title: "Weaviate"
description: "Weaviate implementation for the VectorStore interface, enabling vector similarity search, embeddings storage, and AI-powered features."
icon: "W"
---

## Overview

Weaviate is a `VectorStore` implementation in Bifrost's framework package. It provides a production-ready vector database solution that enables plugins to store embeddings, perform similarity searches, and build AI-powered features like semantic caching, content recommendations, and knowledge retrieval.

**Key Capabilities:**
- **Vector Similarity Search**: Find semantically similar content using embeddings
- **Namespace Management**: Organize data into separate collections with custom schemas
- **Flexible Filtering**: Query data with complex filters and pagination
- **High Performance**: Optimized for production workloads with gRPC support
- **Scalable Storage**: Handle millions of vectors with efficient indexing


## Quick Start

### 1. Set Up Weaviate

**Weaviate Cloud:**
- Sign up at [cloud.weaviate.io](https://cloud.weaviate.io)
- Create a new cluster
- Get your API key and cluster URL

### 2. Configure Vector Store

<Tabs group="vector-store-setup">

<Tab title="Go SDK">

```go
import (
    "context"
    "github.com/maximhq/bifrost/framework/vectorstore"
    "github.com/maximhq/bifrost/core/schemas"
)

// Configure Weaviate vector store
vectorConfig := &vectorstore.Config{
    Enabled: true,
    Type:    vectorstore.VectorStoreTypeWeaviate,
    Config: vectorstore.WeaviateConfig{
        Scheme:    "http",           // "http" for local, "https" for cloud
        Host:      "localhost:8080", // Your Weaviate host
        ApiKey:  "your-weaviate-api-key", // Required for Weaviate Cloud; optional for local/self-hosted

        // Enable gRPC for improved performance (optional)
        GrpcConfig: &vectorstore.WeaviateGrpcConfig{
            Host:    "localhost:50051", // gRPC port
            Secured: false,             // true for TLS
        },
    },
}

// Create vector store
store, err := vectorstore.NewVectorStore(context.Background(), vectorConfig, logger)
if err != nil {
    log.Fatal("Failed to create vector store:", err)
}
```

</Tab>

<Tab title="config.json">

**Local Setup:**
```json
{
  "vector_store": {
    "enabled": true,
    "type": "weaviate",
    "config": {
      "scheme": "http",
      "host": "localhost:8080"
    }
  }
}
```

**Cloud Setup with gRPC:**
```json
{
  "vector_store": {
    "enabled": true,
    "type": "weaviate",
    "config": {
      "scheme": "https",
      "host": "your-weaviate-host",
      "api_key": "your-weaviate-api-key",
      "grpc_config": {
        "host": "your-weaviate-grpc-host",
        "secured": true
      }
    }
  }
}
```

</Tab>

</Tabs>

<Note>
gRPC host will be of format host:port. If host is without a port number then the 80 port for insecured and 443 port for secured connections will be used.
</Note>

## VectorStore Interface Usage

### Creating Namespaces
Create collections (namespaces) with custom schemas:

```go
// Define properties for your data
properties := map[string]vectorstore.VectorStoreProperties{
    "content": {
        DataType:    vectorstore.VectorStorePropertyTypeString,
        Description: "The main content text",
    },
    "category": {
        DataType:    vectorstore.VectorStorePropertyTypeString,
        Description: "Content category",
    },
    "tags": {
        DataType:    vectorstore.VectorStorePropertyTypeStringArray,
        Description: "Content tags",
    },
}

// Create namespace
err := store.CreateNamespace(ctx, "my_content", properties)
if err != nil {
    log.Fatal("Failed to create namespace:", err)
}
```

### Storing Data with Embeddings
Add data with vector embeddings for similarity search:

```go
// Your embedding data (typically from an embedding model)
embedding := []float32{0.1, 0.2, 0.3 } // example 3-dimensional vector

// Metadata associated with this vector
metadata := map[string]interface{}{
    "content":  "This is my content text",
    "category": "documentation",
    "tags":     []string{"guide", "tutorial"},
}

// Store in vector database
err := store.Add(ctx, "my_content", "unique-id-123", embedding, metadata)
if err != nil {
    log.Fatal("Failed to add data:", err)
}
```

### Similarity Search
Find similar content using vector similarity:

```go
// Query embedding (from user query)
queryEmbedding := []float32{0.15, 0.25, 0.35, ...}

// Optional filters
filters := []vectorstore.Query{
    {
        Field:    "category",
        Operator: vectorstore.QueryOperatorEqual,
        Value:    "documentation",
    },
}

// Perform similarity search
results, err := store.GetNearest(
    ctx,
    "my_content",        // namespace
    queryEmbedding,      // query vector
    filters,             // optional filters
    []string{"content", "category"}, // fields to return
    0.7,                 // similarity threshold (0-1)
    10,                  // limit
)

for _, result := range results {
    fmt.Printf("Score: %.3f, Content: %s\n", *result.Score, result.Properties["content"])
}
```

### Data Retrieval and Management
Query and manage stored data:

```go
// Get specific item by ID
item, err := store.GetChunk(ctx, "my_content", "unique-id-123")
if err != nil {
    log.Fatal("Failed to get item:", err)
}

// Get all items with filtering and pagination
allResults, cursor, err := store.GetAll(
    ctx,
    "my_content",
    []vectorstore.Query{
        {Field: "category", Operator: vectorstore.QueryOperatorEqual, Value: "documentation"},
    },
    []string{"content", "tags"}, // select fields
    nil,  // cursor for pagination
    50,   // limit
)

// Delete items
err = store.Delete(ctx, "my_content", "unique-id-123")
```

## Example: Semantic Caching Plugin

Here's how the semantic cache plugin uses the VectorStore:

```go
import (
    "github.com/maximhq/bifrost/plugins/semanticcache"
    "github.com/maximhq/bifrost/core/schemas"
)

// Configure semantic cache plugin with Weaviate backend
cacheConfig := semanticcache.Config{
    // Embedding model configuration (Required)
    Provider:       schemas.OpenAI,
    Keys:          []schemas.Key{{Value: "sk-..."}},
    EmbeddingModel: "text-embedding-3-small",
    
    // Cache behavior
    TTL:       5 * time.Minute,  // Time to live for cached responses
    Threshold: 0.8,              // Similarity threshold for cache lookup
}

// The semantic cache plugin automatically uses the configured vector store
plugin, err := semanticcache.Init(context.Background(), cacheConfig, logger, store)
if err != nil {
    log.Fatal("Failed to create semantic cache plugin:", err)
}

// Add to Bifrost config
bifrostConfig := schemas.BifrostConfig{
    Plugins: []schemas.Plugin{plugin},
    // ... other config
}
```



## Related Documentation

| Topic | Documentation | Description |
|-------|---------------|-------------|
| **VectorStore Interface** | [Framework Overview](../what-is-framework) | Understanding the framework package and VectorStore interface |
| **Semantic Caching** | [Semantic Caching](../../../features/semantic-caching) | Using VectorStore for AI response caching |

---

## Use Cases

### Semantic Caching
Build intelligent caching systems that understand query intent rather than just exact matches.

**Applications:**
- Customer support systems with FAQ matching
- Code completion and documentation search  
- Content management with semantic deduplication

### Knowledge Base & Search
Create intelligent search systems that understand user queries contextually.

**Applications:**
- Document search and retrieval systems
- Product recommendation engines
- Research paper and knowledge discovery platforms

### Content Classification
Automatically categorize and tag content based on semantic similarity.

**Applications:**
- Email classification and routing
- Content moderation and filtering
- News article categorization and clustering

### Recommendation Systems
Build personalized recommendation engines using vector similarity.

**Applications:**
- Product recommendations based on user preferences
- Content suggestions for media platforms
- Similar document or article recommendations

<Info>
**Production Deployment**: For production environments, consider using gRPC configuration for better performance and enable appropriate authentication mechanisms for your Weaviate deployment.
</Info>